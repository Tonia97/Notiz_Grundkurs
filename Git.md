# Git

## Git概述

Git是一个免费的、开源的**分布式版本控制系统**，可以快速高效的处理从小型到大型的各种项目。

Git易于学习，占地面积小，性能极快，它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能由于CVS，Perforce和ClearCase等版本控制工具。

### 何为版本控制

版本控制是一种记录文件内容变化，以便将来查阅特定版本。

版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。

### 为什么需要版本控制

个人开放过渡到团队协作。

### 版本控制工具

#### 集中式版本控制工具

集中化的版本控制系统比如CVS，SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来这已经成为版本控制系统的标准做法。

这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。

缺点式如果中央服务器单点故障，如果服务器宕机一小时，那么在这一个小时内谁都无法提交更新，也就无法协同工作。

####分布式版本控制工具

Git, Mercurial, Bazaar, Darcs......

像Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码库完整的镜像下来（本地库），这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。

分布式版本控制系统出现之后，解决了集中式版本控制系统的缺陷：

1.服务器断网的情况下也可以进行，因为版本控制是在本地进行的；

2.每个客户端保存的也都是整个完整的项目，包含历史记录，更加安全。

### 工作机制和代码托管中心

#### 工作机制

git分为三个区：工作区，暂存区，本地库

工作区：写代码的地方，指代码存放的磁盘的位置，比如在IDE里写代码会生成一个目录在磁盘里，那个目录就称为工作区，也就是存放代码的位置。

暂存区：工作区添加到暂存区用git add指令，临时存储，这时也不会产生历史版本。

本地库：暂存区到本地库用git commit指令，由暂存区提交到本地库，一旦提交到本地库就会产生历史版本，代码就删不掉了。比如有v1，v2，v3这些版本，只删掉v2是不行的，因为v3是基于它的。

远程库：从本地库push到远程库，即代码托管中心。

![工作机制](T:\lernen\Git\bilder\工作机制.jpg)

#### 代码托管中心

代码托管中心是基于网络服务器的远程代码仓库，一般我们简单成为远程库。

代码托管中心一般分为局域网和互联网。

局域网：GitLab

互联网：GitHub

## Git安装

## Git常用命令

| 命令名称 | 作用 |
| :------- | :--- |
| git config --global user.name 用户名 | 设置用户签名 |
| git config --global user.email 邮箱 | 设置用户签名 |
| git init | 初始化本地库 |
| git status | 查看本地库状态 |
| git add 文件名 | 添加到暂存区 |
| git commit -m "日志信息" 文件名| 提交到本地库 |
| git reflog | 查看历史记录 |
| git reset --hard 版本号 | 版本穿梭 |
### 设置用户签名

基本语法：

**git config --global user.name 用户名**

**git config --global user.email 邮箱**

签名的作用是区分不同操作者身份，用户的签名信息在每个版本的提交信息中能够看到，以此确认本次是谁做的。Git首次安装必须设置一下用户签名，否则无法提交代码。

<u>**注意**</u>：这里设置用户签名和将来登录GitHub（或其他代码托管中心）的账号没有任何关系。	

### 初始化本地库

基本语法：

**git init**

打开项目文件夹右键bash模式打开，键入git init，就会完成项目的初始化，并自动在项目文件夹生成一个.git文件，这个文件夹默认是隐藏的且不能修改。

另外.git内的文件不能修改，一旦变动git将不能再打开。

git语法和linux是一样的。

### 查看本地库状态

基本语法：

**git status**

一般回车后有三行

第一行on braunch 提示现在位于哪个分支

第二行有无commit 即有无提交过

第三行有无需要提交的东西，红色显示的文件是tracking到没有提交的，存进暂存区后会变绿，表示追踪到了文件，想删除暂存区的文件用**git rm --catched 文件**指令来删除，注意这个删除只删除add给暂存区的，本地的工作区的源文件不会被删除，并且删除后再git status会发现文件又变成红色，即无法追踪的到的状态。

### 添加暂存区

基本语法：

**git add 文件**

### 提交本地库

基本语法：

**git commit -m “日志信息” 文件名**

日志信息即版本信息，是自己定的，比如first commit

假设提交了一个文件hello回车后会返回：master(root commit) xxxxxx first commit

即master输入日志信息first commit提交了版本信息xxxxxx的hello文件，这个xxxxxx是随机生成的版本信息

commit后再git status会发现第一行仍然是on branch，第二行消失变成nothing to commit

查看版本信息：**git reflog**或**git log**，其中git log更详细，会显示完整的版本号和签名等信息

### 修改文件

使用cat vim等linux指令。

修改文件后git status后bash会显示有修改后的文件（红色），再git add， git commit -m “日志信息” 文件名，注意这里的日志信息要改比如second commit，回车后git会提示说有一个文件被修改，几行增加，几行删除。即修改了几行。

这个时候git reflog会提示已经有两个日志信息了，并且指针指向最新的版本，这个时候再cat，读取到的就是最新版本的文件。

命令行里的modified标识表示这个被追踪的文件已经被修改。

而且要注意指令是一系列的，代码从暂存区到本地库transfer的是同一个文件，push到本地库后暂存区会被清空。

### 版本穿梭

原理就是head指针的移动。

查看版本历史记录基本语法：**git reflog** 或 **git log**

想要穿梭回去其他版本：**git reset --hard 版本号** 注意这里的版本号用git reflog里的简写版即可

穿越成功之后再git reflog指针就会只向穿梭过去的版本号，且log文件里也会记录从穿梭的历史记录。

版本发生变化再cat就会读取原来的文件。

另一种查看方式，打开文件夹里的.git文件的head文件，会告诉是哪个分支，记住分支后打开ref文件夹，找记住的分支名字的文件，打开，记录的就是目前分支正位于的版本号。

## Git分支

### 什么是分支

在版本控制过程中，同时推进多个任务，为每个任务我们可以创建任务的单独分支，使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行，对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层也是指针的引用）

![分支](T:\lernen\Git\bilder\分支.jpg)

![分支1](T:\lernen\Git\bilder\分支1.jpg)

### 分支的好处

同时并行推进多个功能开发，提高开发效率。

### 分支的操作

| 命令名称 | 作用 |
| ------------- | ------- |
| git branch 分支名| 创建分支 |
| git branch -v | 查看分支 |
| git checkout 分支名 | 切换分支 |
| git merge 分支名 | 把指定的分支合并到当前分支上 |

#### 查看分支

基本语法：**git branch -v**

会返回目前有哪些分支

####创建分支

基本语法：**git branch 分支名**

创建完git branch -v会看到出现了新的分支

#### 切换分支

基本语法：**git checkout 分支名**

注意不要和切换版本搞混，切换版本：git reset --hard 版本号

#### 合并分支

##### 正常合并

基本语法：**git merge 要合并的分支名 **

注意是把想要合并的分支合并到当前分支，回车

比如：master没有修改，hot是基于master的基础上修改，所以合并过来不冲突

##### 冲突合并

原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改，git无法替我们决定使用哪一个，必须人为决定新代码内容。

合并冲突时分支和主线不在同一个版本而不是同一个位置做不同修改？

可以用vim手动修改，之后执行提交，注意这一次commit的时候不能带文件名，即git commit -m “日志文件”即可，否则会报错。

提交之后发现当前分支后面的merging消失，就变为正常。

## Git团队协作机制

### 团队内协作

![团队内协作](T:\lernen\Git\bilder\团队内协作.jpg)

### 跨团队协作

![跨团队协作](T:\lernen\Git\bilder\跨团队协作.jpg)

git pull相当于git fetch和git merge。 其意思是先从远程下载git项目里的文件，然后将文件与本地的分支进行merge。 clone克隆字如其名，简单理解就是把远程代码克隆到本地，pull 拉取远程代码+ 执行合并操作。

## GitHub操作

GitHub: <https://github.com/>

### 创建远程库

登录--右上角铃铛旁边的加号“+”有new repository，要写远程库的名字（一般来说远程库和本地库的名字是一样的），远程库是基于账号的，所以重名也没关系--之后选择库（public，private）--其他的可以不用选 直接create repository

进入远程库之后会看到quick setup，下面有HTTPS和SSH两个，选择HTTPS复制，直接就是远程库的链接。

### 远程库操作

| 命令名称 | 作用 |
| ---------- | --- |
| git remote -v | 查看当前所有远程地址别名 |
| git remote add 别名 远程地址 | 起别名 |
| git push 别名 分支 | 推送本地分支上的内容到远程仓库 |
| git clone 远程地址 | 将远程仓库的内容克隆到本地 |
| git pull 远程库地址别名 远程分支名 | 当远程库对于分支最新内容拉下来后与当前本地分支直接合并 |
| git remote rm 远程库别名 | 可以直接删除库 |

#### 创建别名

两个命令结合使用：

**git remote -v** 查看当前所有远程地址别名（没有的话就起一个，则用到下一步的指令）

**git remote add 别名 远程地址的链接**：这里建议别名和远程库名字一样

####推送本地库到远程库

#####HTTP方法

基本指令：**git push 别名 分支**

将本地的 [branch] 分支（比如master）推送成为别名远程仓库上的 [branch] 分支

##### SSH方法



#### 拉取远程库到本地

指令：**git pull 远程库别名 远程分支名**

拉取动作会自动提交本地库，即git status后没有红标文件

#### 远程库克隆到本地库

指令：**git clone http链接**

克隆代码不需要登录账号

克隆做以下工作：拉取代码，初始化本地库（init），创建别名（origin）

### 协作

####团队内协作

有链接就可以clone，但是要推送上去必须有权限

github的website--settings--manage access--invite a collaborator

#### 跨团队协作

复制远程库链接进入website，点击右上角的fork，然后会在自己的界面看到这fork的项目，修改之后只是修改了自己的库里面的东西，如果想推给别的团队，需要点击github里的pull request，再点击create pull request，然后写上自己的“日志文件”（比如xxxcommit），可以在wirte栏里写上附上的备注，同样的，远程库的拥有者可以在pull request里看到请求，检查代码没有问题后选择merge  pull request即可完成合并更新

#### SSH远程登录

SSH没有key不能用，因此需要添加ssh的免密公钥

首先进入windows家目录，用户名下面有一个.ssh的目录，先删除，之后右键打开bash，利用非加密协议算法生成新的.ssh文件，指令： **ssh -keygen -t rsa -C xxxx@xx.xx**

xxxx@xx.xx, 免密协议是哪个账号分配的就输入哪个账号的邮箱（即远程库所有人的邮箱），指令输完三次回车，会发现家目录里重新生成.ssh文件，打开后里面有rsa文件，打开pub（即public）那一个，使用公钥，**cat id_ras.pub**,复制得到的信息，到github网页上点击登录者头像找settings，在账号设置里有找**ssh&gdp keys**，添加new SSH key，这样windows连接此账号就不再需要公钥，

##IDEA集成Git(IDEA用于java)

### 配置Git忽略文件

#### 为什么忽略？

与项目实际功能无关，不参与服务器上部署运行，把他们忽略掉可以屏蔽IDE工具之间的差异。

#### 怎么忽略？

1.创建忽略规则文件xxxx.ignore (建议git.ignore)，这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig文件引用，建议放在用户家目录下。

```c
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

hs_err_pid*

.classpath
.project
.settings
target
.idea
*.iml
```

之后需要在git.config文件里引用这个文件，新加一行：

```c
[Core]
	excludesfile = git.ignore绝对路径，且改变\方向为“/”方向
```

### 定位Git程序

进入ide文件，创建一共新的projekt，在groupid那里输入com.xxx



## IDEA集成GitHub

## 国内代码托管中心 码云

## 自建代码托管平台GitLab

